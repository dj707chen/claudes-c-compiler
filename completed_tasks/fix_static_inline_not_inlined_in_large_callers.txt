Task: Fix static inline functions not inlined in large callers causing linker errors
Status: completed

Problem:
  fs/netfs/buffered_write.c compiled with CCC causes x86 kernel link failure:
    undefined reference to `__fscache_clear_page_bits'
  
  Root cause: fscache_clear_page_bits() is a static inline with an if/else
  (2+ blocks). The caller grows too large (>200 IR instructions) after inlining
  other functions, so the "caller too large" check blocks normal inlining.
  The "tiny" first pass (<=5 instructions, 1 block) doesn't match either.
  
  GCC inlines these small wrappers regardless of caller size.

Fix:
  Added MAX_SMALL_INLINE_INSTRUCTIONS (20) and MAX_SMALL_INLINE_BLOCKS (3).
  Extended the first-pass "always inline" check in the inline loop to also
  cover "small" callees (not just "tiny" ones). This ensures small static
  inline functions with 2-3 blocks are inlined even when the caller is large,
  preventing linker errors from conditional references to undefined symbols.

Related: fix_tiny_inline_threshold_for_guard_patterns.txt addresses the same
root cause from a different angle (raising the tiny threshold instead of
adding a separate "small" category).
