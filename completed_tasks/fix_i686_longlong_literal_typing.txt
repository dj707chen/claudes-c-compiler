Task: fix_i686_longlong_literal_typing
Status: COMPLETED
Date: 2026-01-28

## Problem

On i686 (ILP32), `long` is 32-bit but `long long` is always 64-bit. The compiler
conflated L and LL integer literal suffixes into the same LongLiteral/ULongLiteral
token and AST variants. This caused LL-suffixed literals to be typed as 32-bit on
i686, leading to constant folding truncating 64-bit results to 32 bits.

Example: `0xf0000000ULL + 0x10000000ULL` evaluated to 0 instead of 0x100000000
because both operands were typed as ULong (4 bytes on i686), and the result was
truncated via wrap_result(0x100000000, is_32bit=true).

## Root Cause

parse_int_suffix() returned (is_unsigned, is_long, is_imaginary) with no way to
distinguish `L` from `LL`. make_int_token() mapped both to LongLiteral/ULongLiteral.
On i686, these are typed as CType::Long/CType::ULong (32-bit), so constant folding
used is_32bit=true and truncated results.

## Fix

Added LongLongLiteral(i64) and ULongLongLiteral(u64) variants to:
- TokenKind (lexer tokens)
- Expr (AST nodes)

Updated parse_int_suffix() to return 4-tuple (is_unsigned, is_long, is_long_long,
is_imaginary) and updated make_int_token() to create the new token variants for
LL/ULL suffixes.

Updated all 18 downstream match arms across the pipeline:
- Parser: token-to-AST conversion
- Sema: type checking, designator eval, const eval
- IR lowering: expr lowering, type inference, const eval, complex numbers
- Common: const_eval, const_arith (is_zero)

LL/ULL literals are always typed as CType::LongLong/CType::ULongLong (64-bit)
regardless of target pointer size.

## Files Modified (14)

- src/frontend/lexer/token.rs - New TokenKind variants
- src/frontend/lexer/lexer.rs - parse_int_suffix, make_int_token
- src/frontend/parser/ast.rs - New Expr variants
- src/frontend/parser/expressions.rs - Token-to-Expr conversion
- src/frontend/parser/declarations.rs - Enum const eval
- src/frontend/sema/sema.rs - Designator index, analyze_expr
- src/frontend/sema/type_checker.rs - Type rules for new variants
- src/frontend/sema/const_eval.rs - Literal delegation, array sizes
- src/ir/lowering/complex.rs - expr_ctype
- src/ir/lowering/expr.rs - Literal-to-operand, type inference
- src/ir/lowering/expr_types.rs - IrType, byte size, CType
- src/ir/lowering/const_eval.rs - Literal delegation, array sizes
- src/common/const_eval.rs - eval_literal
- src/common/const_arith.rs - is_zero_expr

## Test Results

- loop-termination (i686): 1830/1830 (100%), up from 1655/1830 (90.4%)
- x86 kernel: PASS
- x86-64 suite: no regressions
- ARM suite: no regressions
- RISC-V suite: no regressions
