Task: Fix global pointer/64-bit array initialization emitting .long instead of .quad

Problem:
When initializing a global array of pointers like `int *arr[3] = {0, 0, 0}`,
the compiler emits `.long 0` (4 bytes) for each element instead of `.quad 0` (8 bytes).
This results in only partial zero-initialization of the array.

Root cause:
In src/backend/common.rs, the GlobalInit::Array handler infers the element type from
the IrConst variant (IrConst::I32 -> IrType::I32) rather than using the global's
declared type. Since C's `0` literal is int (4 bytes), pointer zero-initializers
get stored as IrConst::I32(0) and emitted as `.long 0` instead of `.quad 0`.

Fix:
When emitting GlobalInit::Array elements, if the global's declared type is wider than
the constant's intrinsic type (e.g., Ptr or I64 vs I32), use the global type to
determine the directive size.

Affected architectures: ARM, RISC-V (not x86 due to different section handling)
