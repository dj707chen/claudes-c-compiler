Fix: __attribute__((cleanup)) goto scope bug

The goto statement was incorrectly calling cleanup destructors for ALL active scopes,
even when jumping to a label within the same scope. This caused double-cleanup in
patterns like:

    void f(void) {
        guard_t g __attribute__((cleanup(destructor))) = ...;
        if (cond) goto out;
        ...
    out:
        return; // destructor called correctly here at scope exit
    }

The goto was calling the destructor before the jump AND at scope exit, causing
"preemption imbalance" kernel warnings and boot failures when kernel/sched/core.c
was compiled with our compiler.

Fix: Pre-scan the function body AST to record label scope depths, then in goto
lowering, only emit cleanup calls for scopes actually being exited (scopes deeper
than the target label's scope).
