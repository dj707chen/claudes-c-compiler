Fix: brace-elided initialization consumes address/pointer values into sub-structs

Bug: When a struct with sub-struct fields is initialized using brace-elided (flat)
initialization, address-type expressions (function pointers, &var, string literals)
that should go to the next top-level field are instead consumed by the preceding
sub-struct. The sub-struct truncates the pointer value, leaving the target field as 0.

Example:
  typedef struct { unsigned char a, b, c; } Inner;
  typedef struct { Inner x; void *y; } Outer;
  Outer test = {1, 2, 3, "hello"};
  // GCC: x={1,2,3}, y="hello"
  // CCC: x={1,2,3}, y=NULL  (BUG: "hello" consumed by Inner x)

This breaks lcc (all architectures) and likely many other projects using
brace-elided initialization with pointer/address values after sub-struct fields.

Root cause: In the initializer parsing code, the brace-elision logic uses some
heuristic to decide when to stop consuming values for a sub-struct, but this
heuristic incorrectly treats address expressions as valid for unsigned char fields.

Status: in_progress
Started: 2026-01-30
