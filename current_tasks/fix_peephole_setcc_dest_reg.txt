Fix: peephole store forwarding misses setCC destination register

The global_store_forwarding peephole pass doesn't recognize x86 setCC
instructions (sete, setne, seta, setb, etc.) as writing to a register.
parse_dest_reg_fast returns REG_NONE for these single-operand instructions,
so the store forwarding doesn't invalidate the slot->register mapping when
a setCC clobbers a byte sub-register.

This causes incorrect code: after an inline asm block stores a value via
ecx to a stack slot, global_store_forwarding records the slot->ecx mapping.
A subsequent asm block writes sete %cl, which clobbers ecx. But the mapping
isn't invalidated because parse_dest_reg_fast doesn't detect the setCC dest.
When the original value is loaded back, the forwarding replaces the stack
load with a register read (movl %ecx, %eax), reading the clobbered value.

Fix: add setCC recognition to parse_dest_reg_fast.
