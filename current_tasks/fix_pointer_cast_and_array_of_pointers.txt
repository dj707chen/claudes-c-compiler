Task: Fix pointer cast codegen, parser, and array-of-pointers handling

Bug 1: Pointer cast parser losing pointer level
Problem: (int *)expr was parsed as Cast(Int, expr) instead of Cast(Pointer(Int), expr)
because the parser consumed the * tokens but didn't wrap the type in TypeSpecifier::Pointer.
Fix: In parse_unary_expr, after parsing the type specifier in a cast expression,
consume * tokens and wrap in TypeSpecifier::Pointer (with const/volatile/restrict handling).

Bug 2: Arrays of pointers treated as pointer-to-base
Problem: int *arr[3] was treated as a pointer to int array instead of an array of 3 int pointers.
The derived declarator order (Pointer before Array) wasn't checked in compute_decl_info.
Fix: In compute_decl_info, when both pointer and array derived declarators exist,
check position order. If pointer comes first (ptr < arr), it's an array of pointers.

Bug 3: Cast to pointer corrupts value with cltq (sign-extend)
Problem: (int *)arr or (long)arr on arrays generates a Cast IR instruction from I32->Ptr
or I32->I64, which emits cltq (sign-extend eax to rax) on x86, sxtw on ARM, sext.w on RISC-V.
This corrupts the 64-bit pointer address from leaq. Root cause: get_expr_type returns
the element type (I32) for array identifiers, not the actual runtime type (Ptr, since
arrays decay to pointers in lower_expr).
Fix:
- In Expr::Cast lowering (expr.rs): detect when inner expr is an array/struct identifier
  and correct from_ty to Ptr. Also make cast TO Ptr always pass-through since the value
  is already correct from lower_expr.
- In emit_cast_instrs (all 3 backends): include Ptr in same-size no-op check and
  normalize Ptr to I64 before widening/narrowing logic.

Status: Complete
