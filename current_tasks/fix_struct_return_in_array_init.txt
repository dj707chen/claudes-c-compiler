Task: Fix struct-returning function call in local struct array initializer
Status: Completed

Problem:
When a function returns a struct via the sret convention (hidden pointer for structs
> 8 bytes) and the return value is used to initialize a struct/union field within a
local array of structs, the compiler stored the sret alloca pointer address instead
of memcpy'ing the actual struct contents to the target field.

Example:
    struct pair { void* first; void* last; };
    struct item { const char* name; struct pair data; };

    struct pair make_pair(void* a, void* b);

    struct item items[] = {
        {"first",  make_pair(a, b)},  // data.first was stack addr, not 'a'
        {"second", make_pair(b, a)}
    };

Root cause:
In lower_local_struct_init (stmt.rs), the Initializer::Expr path used
lower_and_cast_init_expr which returns the sret alloca address (a pointer) for
struct-returning function calls. This pointer was then stored as a scalar value
to the field, rather than memcpy'ing the struct contents from the alloca.

The fix adds a check: if the field type is CType::Struct or CType::Union and the
expression produces a struct value (detected via struct_value_size), use
get_struct_base_addr + Memcpy instruction instead of a scalar Store. This matches
the correct pattern already used in emit_struct_init.

Fix location:
- src/ir/lowering/stmt.rs: lower_local_struct_init, Initializer::Expr branch

This fixes jq segfaults in block_bind_subblock_inner (3 more jq tests passing,
from 1/12 to 3/12) and likely many other struct init issues.
