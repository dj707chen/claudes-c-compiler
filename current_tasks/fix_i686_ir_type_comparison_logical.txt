Task: Fix i686 IR type for comparisons, logical ops, and call argument handling
Status: in_progress
Started: 2026-01-28

Description:
On i686, comparison operators (==, !=, <, >, <=, >=), logical operators (&&, ||),
and logical NOT (!) were producing I64-typed values. Since on i686 int is 32-bit,
this caused two problems:

1. Register-allocated I64 values in emit_call_stack_args were silently dropped
   (the code only checked get_slot() which returns None for reg-allocated values)

2. I64-typed comparison/logical results took 8 bytes on the variadic arg stack
   instead of 4, misaligning subsequent arguments

Fixes:
- Added target_int_ir_type() helper (I32 on ILP32, I64 on LP64)
- Fixed get_binop_type() to return target_int_ir_type() for comparisons/logical ops
- Fixed lower_short_circuit() to use target int type for alloca, stores, comparisons
- Fixed LogicalNot to use target int type
- Fixed ternary/conditional operator to use target int type for allocas and pointers
- Fixed emit_call_stack_args to handle register-allocated I64/F64/I128/F128 values
