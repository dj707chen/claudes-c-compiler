Fix inline asm %P modifier failing when "+" (read-write) constraints are present.

Problem:
When an inline asm statement has "+" (read-write) output constraints, the
gcc_to_internal operand number mapping is incorrect for subsequent input
operands. This causes template substitution to fail for patterns like %P4,
resulting in literal "%P4" appearing in the output assembly instead of the
resolved immediate value.

Root cause:
The gcc_to_internal mapping in src/backend/inline_asm.rs computes the total
number of GCC operands as outputs.len() + (inputs.len() - num_plus). But
GCC's actual numbering counts "+" constraints as single operands (numbering
outputs first, then non-synthetic inputs). The issue is that when building
gcc_to_internal, the input loop skips the first num_plus inputs (which are
synthetic) but the GCC numbering already accounts for this differently.

Fix:
Correct the gcc_to_internal mapping so that GCC operand numbers correctly
map to internal operand indices when "+" constraints create synthetic input
operands.

Test: /tmp/test_asm_call2.c with "+r" constraint and %P4 modifier.
Kernel impact: Fixes COMPILE_FAIL for kernel/groups.c and boot failures
for files using get_user/put_user macros.
