Fix URem/UDiv by power-of-2 optimization not firing for I64-typed unsigned ops

Bug: On 64-bit targets, C integer promotion widens `unsigned int` operations
to I64 (via widened_op_type()). The simplify pass's URem-by-power-of-2 → And
optimization requires ty.is_unsigned(), which is false for I64. This means
`unsigned x % 16` uses a div instruction instead of `and $15, %eax`.

The op code URem already encodes unsigned semantics - the type signedness
check is unnecessary and overly restrictive.

Similarly, UDiv by power-of-2 → LShr may need the same fix in simplify.rs.

Fix: Remove the ty.is_unsigned() check from the URem power-of-2 strength
reduction in simplify.rs. The unsigned semantics are encoded in the op code
(URem vs SRem), not the type.

Note: This is different from add_64bit_div_by_const.txt which adds genuine
64-bit magic number computation. This fix makes existing 32-bit optimizations
work correctly when the IR type is I64 due to C integer promotion.

Started: 2026-02-05
