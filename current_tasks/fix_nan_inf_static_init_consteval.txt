Task: Fix NaN/Infinity/huge_val static initialization in constant evaluator
Status: in_progress
Started: 2026-01-30

Problem:
Global/static variables initialized with NAN, INFINITY, or __builtin_nan/inf/huge_val
builtins are silently zero-initialized instead of receiving the correct special float
values. For example:

    volatile double d_nan = NAN;       // gets 0.0 instead of NaN
    double d_inf = INFINITY;           // gets 0.0 instead of +Infinity
    double d = __builtin_nan("");      // gets 0.0 instead of NaN

Root cause:
The shared constant evaluator (common/const_eval.rs::eval_builtin_call) did not handle
__builtin_nan*, __builtin_inf*, or __builtin_huge_val* builtins. When these appeared in
global initializer expressions, eval_const_expr returned None, causing the global init
path to fall through to GlobalInit::Zero.

These builtins were registered as ConstantF64 in sema/builtins.rs and handled during
IR lowering (expr_builtins.rs), but NOT in the constant evaluation path used by
global_init.rs.

Fix:
Add all NaN/Infinity/huge_val builtin variants to eval_builtin_call so they resolve
to the correct IrConst::F64/F32/LongDouble values during constant evaluation.

Impact:
Fixes QuickJS test_builtin.js ("aaa".lastIndexOf("a", NaN) returns 0 instead of 2)
and likely many other projects that use NAN/INFINITY macros in static initializers.
