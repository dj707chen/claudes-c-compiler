Task: fix_bitfield_struct_layout_packing
Status: completed
Description: Fix SysV ABI bitfield layout when bitfields follow or precede non-bitfield struct members.

Bug: CCC always aligned the first bitfield in a sequence to its declared type's natural alignment,
even when the bitfield could fit in the same storage unit as preceding non-bitfield members. This
caused structs like { u8 a; unsigned int b:1; } to be 8 bytes instead of 4. Similarly, when a
non-bitfield member followed a bitfield, CCC advanced past the entire storage unit rather than
just past the used bits, preventing the non-bitfield from packing into remaining space.

Example:
  struct acpi_osi_config {       // Linux kernel struct
      u8 default_disabling;
      unsigned int linux_enable:1;
      unsigned int linux_dmi:1;
      ...
  };
  CCC: sizeof = 8 (wrong), GCC: sizeof = 4 (correct)

Root cause: In for_struct_with_packing() in types.rs, the "start new storage unit" path
(line 338) unconditionally aligned the offset to field_align when !in_bitfield. Per the SysV ABI,
a bitfield should first attempt placement at the current bit position and only advance to a new
aligned storage unit if it would straddle a sizeof(T)*8-bit boundary.

Similarly, when transitioning from bitfield to non-bitfield (line 399), the code jumped to
bf_unit_offset + bf_unit_size (end of storage unit) instead of advancing past only the used bits.

Fix: (1) When placing the first bitfield after non-bitfield members, try the current abs_bit_pos
first and only align to a new unit if the bitfield would straddle. (2) When transitioning from
bitfield to non-bitfield, advance to ceil(used_bits / 8) instead of end-of-storage-unit.

Files modified:
  - src/common/types.rs: Fixed bitfield placement in for_struct_with_packing()

Test: tests/bitfield-after-nonbitfield-packing/main.c

Kernel bisect: 26/30 files pass (up from ~19/30 before fix). drivers/acpi/osi.c struct size
now matches GCC. Remaining failures are a separate bug.
