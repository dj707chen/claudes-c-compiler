Fix ARM struct-by-value register argument missing reg_assignments check

Problem:
When passing a struct by value as a function argument on AArch64, and the struct's
address comes from a GEP (array element access), the Phase 3c code in ARM
emit_call_reg_args fails to check reg_assignments before falling back to get_slot.

The GEP result (address of the struct in the array) is register-allocated to a
callee-saved register (e.g., x20), but the struct arg loading code only checks
get_slot, not reg_assignments. This causes it to load from the wrong stack location,
passing garbage data to the function.

Reproduction:
  struct S { long val; };
  long recv(struct S s) { return s.val; }
  int main() {
      struct S arr[3] = {{10}, {20}, {30}};
      // arr[0] works (alloca base), arr[1]/arr[2] fail (GEP results in registers)
      return recv(arr[1]); // returns garbage instead of 20
  }

Root cause:
ARM codegen Phase 3c (emit_call_reg_args) for StructByValReg only checks
self.state.get_slot() but does NOT check self.reg_assignments first.
Compare with:
- RISC-V Phase 3c (line ~1984) which correctly checks reg_assignments first
- ARM stack args (line ~1815) which correctly checks reg_assignments first
- x86 uses operand_to_rax which correctly checks reg_assignments

Fix:
Add reg_assignments check before get_slot check in Phase 3c of ARM emit_call_reg_args.
