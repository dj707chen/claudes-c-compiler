Fix long double (F128) function call argument passing on x86 (in_progress)

Problem: When passing a long double value as a function argument on x86-64,
the emit_call_stack_args function incorrectly uses `movq` to load 8 bytes
from the value's stack slot and then converts via `fldl` (as f64). But when
the value is in f128_direct_slots, the slot contains a full 80-bit x87
extended precision value (16 bytes), not an f64. Reading only 8 bytes with
movq gives garbage (the mantissa bytes interpreted as f64).

Fix: Check f128_direct_slots in the F128Stack arg push path. If the value
has full precision in its slot, use `fldt` to load directly from the slot
instead of the movq+fldl path.

This affects ~100+ test failures involving creall/cimagl, long double printf,
and complex long double operations on x86.
