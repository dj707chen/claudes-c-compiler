Task: Fix RISC-V inline asm "rK" constraint to use immediate for constant local variables
Status: in_progress

Problem:
The Linux kernel's csr_swap() macro uses the "rK" inline asm constraint:
  unsigned long __v = (unsigned long)(val);
  asm("csrrw %0, csr, %1" : "=r"(__v) : "rK"(__v) : "memory");

When val is 0, GCC recognizes that __v holds a constant and selects the K
(5-bit unsigned CSR immediate) alternative, emitting "csrrwi %0, csr, 0".
CCC did not recognize K as an immediate constraint and always used the r
(register) alternative, materializing the constant through stack spills.

This caused a fatal crash in set_satp_mode() during RISC-V kernel boot:
after "csrw satp" enables paging, the stack accesses to load the spilled
value fault because the stack is not identity-mapped.

Fix:
1. Added 'K' to constraint_has_immediate_alt() in src/backend/inline_asm.rs
   so the IR lowering attempts constant evaluation for "rK" constraints.

2. Added try_recover_local_const() in src/ir/lowering/stmt_asm.rs that
   scans recent IR instructions backward to recover constant values from
   non-const local variables. This handles the kernel pattern where a
   non-const local __v is initialized with a constant like 0. The method
   follows one level of Value indirection (Cast/Copy) to handle casts
   like (unsigned long)(5).

Files modified:
- src/backend/inline_asm.rs
- src/ir/lowering/stmt_asm.rs

Test:
- tests/riscv-csr-swap-local-var-immediate-riscv/
