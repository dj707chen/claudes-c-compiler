Fix flexible array member subscript computing element size as zero

Bug: When computing &obj->elements[i] on a struct with a flexible array member
(struct with [] at end), the array subscript computes the element size as 0.
This means &obj->elements[0] and &obj->elements[N] return the same address.

Root cause: The flexible array member has size 0 in the struct layout (which is
correct for sizeof(struct)), but this zero size is being used as the element size
for array subscript pointer arithmetic, where the actual element type's size
should be used instead.

Impact: Causes jq to crash (all 12 tests fail with SIGABRT). The hashbucket
initialization loop writes -1 values to the wrong memory location (overlapping
with the elements array), corrupting struct data.

Minimal reproducer:
  typedef struct { int header; S elements[]; } Container;
  Container* c = malloc(...);
  &c->elements[4]  // returns same address as &c->elements[0] (BUG)

Status: IN PROGRESS
