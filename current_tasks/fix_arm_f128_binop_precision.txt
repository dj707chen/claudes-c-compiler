Task: Fix ARM F128 binary operation precision loss
Status: in_progress

Problem:
On AArch64, long double is 128-bit IEEE quad precision (F128). The ARM backend's
emit_f128_binop_softfloat_full() function correctly calls __divtf3/__addtf3/etc.
to perform the arithmetic at full precision, but then immediately truncates the
result to f64 via __trunctfdf2 and stores only 8 bytes. When the result is later
needed at full precision (e.g., for return or comparison), the f64 is extended
back via __extenddftf2, which produces a different (less precise) value.

This causes the long-double-arithmetic test to fail (return code 4) because
the runtime division result differs from the compile-time constant-folded value.

Fix:
After the arithmetic libcall returns the full f128 result in Q0, store the full
16-byte value to the destination slot BEFORE truncating to f64. Then call
track_f128_self() so that subsequent uses can reload the full-precision value.
