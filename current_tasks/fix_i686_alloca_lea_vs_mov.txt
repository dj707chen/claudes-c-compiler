Task: Fix i686 codegen to use LEA instead of MOV for alloca values
Status: in_progress

Problem:
The i686 backend's operand_to_eax() and operand_to_ecx() functions always use `movl`
(load value) to load from stack slots, even for alloca values. Alloca values represent
the ADDRESS of stack-allocated memory, so they need `leal` (load effective address).

This causes massive segfaults (~1060 out of ~2737 tests) because when passing arrays
or pointers-to-locals as function arguments, the VALUE at the stack slot is passed
instead of the ADDRESS of the stack slot.

Fix:
- Check `self.state.is_alloca(v.0)` in operand_to_eax/operand_to_ecx
- Use `leal offset(%ebp), %reg` for alloca values instead of `movl offset(%ebp), %reg`
- Handle over-aligned allocas with addl/andl alignment computation
- Track the is_alloca flag in the register cache for proper cache behavior

Result:
i686 pass rate improved from 36.1% to 53.8% (~480 additional tests passing).
Segfaults reduced from 1060 to 80.
