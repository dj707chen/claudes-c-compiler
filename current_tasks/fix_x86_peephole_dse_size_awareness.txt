Fix x86 peephole optimizer: size-aware dead store elimination and store forwarding

The x86 peephole DSE was comparing stores by offset only, ignoring sizes.
This caused incorrect elimination of wider stores (e.g., movq 8-byte zero)
when a narrower store (e.g., movl 4-byte write) followed at the same offset.

Bug manifested as partial struct/union initialization failures:
  struct S { int a, b, c; } x = { 1 };
  // x.b and x.c should be 0 but were garbage

Fix: DSE and store forwarding now track byte ranges [offset, offset+size)
and only consider a store dead when fully covered by a subsequent write.
