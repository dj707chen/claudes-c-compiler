Task: fix_compound_literal_global_aggregate_init
Status: in_progress

Problem:
Compound literals at global scope containing single-field structs where the field
is an array (or nested aggregate) emit only the first element instead of the full
initializer. Example:

  typedef struct { int arr[3]; } arr_t;
  arr_t tA = (arr_t){ { 100, 200, 300 } };
  // Only emits .quad 100, losing elements 200 and 300

Root cause: In const_eval.rs eval_const_expr(), the CompoundLiteral handler checks
layout.fields.len() > 1 to decide if this is a "multi-field aggregate". A struct with
a single array field has fields.len() == 1, so it falls through to eval_const_initializer_scalar()
which only extracts the first scalar value.

Fix: Also check if the single field is itself an aggregate type (array/struct/union),
so that the compound literal goes through the proper struct initialization path
in global_init.rs instead of being short-circuited to a single scalar.
