Bug: struct parameters containing _Complex fields have broken member access

Root cause: In lowering.rs, when setting up struct parameters in lower_function_def,
the `param_ctype` (which becomes VarInfo.c_type) is only set when `is_complex_param`
is true. For a struct like `struct S { double _Complex cx; }`, the parameter's type
spec resolves to a struct type, not a complex type, so `is_complex_param` is false
and `param_ctype` is set to None.

This means `expr_ctype(Identifier("s"))` returns CType::Int (the fallback), causing
`expr_ctype(MemberAccess(s, "cx"))` to also return CType::Int. Then
`lower_complex_real_part` takes the non-complex branch and returns the raw field
address instead of loading the real part from it. The return codegen then inserts a
Cast(Ptr -> F64) which generates `cvtsi2sdq` (integer-to-float conversion of the
address value) instead of a proper memory load.

Fix: Always compute and set param_ctype for struct parameters, not just complex ones.

Reproduction:
  struct S { double _Complex cx; };
  double get_real(struct S s) { return __real__ s.cx; }
  // Returns garbage (the address cast to double) instead of the real part value

This also affects __imag__ and other complex operations on struct member access.
