Fix i686 64-bit conditional branch (I64/F64 truthiness test)

Status: in_progress

Problem:
When evaluating `if (double_expr)` or `if (long_long_expr)` on i686,
the backend only loads the low 32 bits of the 64-bit value into eax
and tests that. For doubles like 1.0 (IEEE 754: 0x3FF0000000000000),
the low 32 bits are zero, so the condition is incorrectly false.

The same bug affects I64 values where the low 32 bits happen to be zero
but the high 32 bits are nonzero.

Root cause:
- emit_cond_branch_blocks calls emit_load_operand which calls operand_to_eax
- operand_to_eax only loads the low 32 bits of I64/F64 values
- emit_branch_nonzero tests only eax (32 bits)

Fix:
Override emit_cond_branch_blocks for i686 to handle 64-bit types:
- For I64/U64: load both halves, OR them together, then test
- For F64: use FPU comparison against zero
- For F32: current approach works fine (32 bits fit in eax)

This affects ~40+ failing tests including double conditionals, long long
conditionals, and various computation tests.
