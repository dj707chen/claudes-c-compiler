Task: Fix ARM inline asm unsigned 32-bit operand zero-extension

Problem: When a 32-bit unsigned int constant (e.g., 0xF0000000u) is loaded into a
64-bit X register for use as an inline assembly input operand, the compiler sign-extends
it instead of zero-extending it. This causes incorrect behavior when the inline asm
uses X-register form operations (e.g., "lsr %[dst], %[src], #4").

Example:
  unsigned int val = 0xF0000000u;
  asm volatile("lsr %[dst], %[src], #4" : [dst] "=r" (res) : [src] "r" (val));
  // Expected: res = 0x0F000000 (zero-extended before shift)
  // Actual:   res = 0xFF000000 (sign-extended, upper bits shifted down)

Root cause: Constant materialization for 32-bit unsigned types uses movn/movk
which sign-extends, when it should use movz/movk to zero-extend.

Fix: In ARM codegen, when materializing a 32-bit unsigned integer constant into
a 64-bit register, ensure zero-extension (use movz instead of movn when the value
fits in 32 bits and the type is unsigned).

Affects test: asm-shift-arm-005b-run2
