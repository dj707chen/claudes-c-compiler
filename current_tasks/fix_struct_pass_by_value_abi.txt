Fix struct/union pass-by-value calling convention (ABI bug)

CCC passes all structs by pointer (address in a single register), but the
x86-64 SysV ABI requires structs <= 16 bytes (with all INTEGER-class fields)
to be passed by value in registers. This causes ABI incompatibility with
GCC-compiled code and is the root cause of the PostgreSQL initdb crash.

The bug manifests as:
- Struct fields get garbage values when crossing CCC/GCC compilation boundaries
- Arguments after the struct get shifted to wrong registers
- PostgreSQL's RelFileLocator (12 bytes, 3 x Oid) gets corrupted

Fix needed in:
- Backend codegen: emit_call must pack small structs into registers at call sites
- Backend codegen: function prologues must unpack register-passed structs
- Both caller and callee sides need fixing for all three backends (x86, ARM, RISC-V)

Status: COMPLETE (all three backends: x86-64, ARM64, RISC-V)

Implementation:
- Added struct_size to IrParam and struct_arg_sizes to Call/CallIndirect IR instructions
- x86 emit_call: classifies struct args by size (<=8: 1 GP reg, 9-16: 2 GP regs, >16: MEMORY on stack)
- x86 emit_store_params: unpacks register data or copies stack data into callee allocas
- ARM64 emit_call: classifies struct args ('V' for regs, 'v'/'M' for stack), loads from memory into arg regs
- ARM64 emit_store_params: stores register-passed struct data into callee allocas, copies stack structs
- RISC-V emit_call: classifies struct args ('V' for regs, 'v'/'M' for stack), loads from memory into arg regs
- RISC-V emit_store_params: stores register-passed struct data into callee allocas, copies stack structs
- ARM struct-passing failure rate: 81% -> 14.3%
- RISC-V struct-assignment failure rate: 54.8% -> 19.4%
