Task: Fix x86 long double (F128) precision - use x87 FPU instead of SSE

Problem: The x86 backend treats long double (F128) as double (F64) at computation
level, using SSE instructions. This loses precision because:
- x87 80-bit extended has 64-bit mantissa (can represent all int64 values exactly)
- SSE double has 53-bit mantissa (loses precision for large int64 values)

Specific issues:
1. Integer-to-F128 casts use cvtsi2sd (double precision) instead of fild (x87)
2. F128-to-integer casts use cvttsd2si instead of fistp
3. F128 binary operations use SSE addsd/subsd/mulsd/divsd instead of x87 fadd/fsub/fmul/fdiv
4. F128 comparisons use SSE ucomisd instead of x87 fcomip

Fix plan:
- Modify emit_cast_instrs_x86() to handle F128 specially using x87 instructions
- Modify emit_float_binop() for F128 to use x87 instructions
- Modify F128 comparisons to use x87
- Fix constant folding for integer->F128 precision

This is x86-specific. ARM and RISC-V treat long double differently.
