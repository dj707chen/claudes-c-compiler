Bug: unsized-struct-array-flat-init test failure

Problem:
  sizeof() returned wrong values for unsized struct arrays with flat initializers
  when the struct element type contains array fields.

  Example:
    typedef struct { long c[4]; long b, e, k; } PT;  // 7 scalar fields
    PT cases[] = {1,2,3,4,10,20,30, 5,6,7,8,50,60,70, 9,10,11,12,90,100,110};
    // sizeof(cases)/sizeof(cases[0]) should be 3 (21 items / 7 per struct)
    // but returned 21 (counted each scalar item as one array element)

Root cause:
  The sema pass's count_initializer_elements() function (sema.rs) counted raw
  initializer items without considering that struct element types with array
  members consume multiple scalar items per struct element. It treated each
  scalar initializer as one array element instead of grouping them per-struct.

  The lowering pass had correct logic (compute_struct_array_init_count with
  flat_scalar_count) but that only affected DeclAnalysis.alloc_size (code gen),
  not the CType seen by sizeof const-evaluation.

Fix:
  1. Changed count_initializer_elements from static fn to &self method to
     access struct layout information via self.result.type_context.
  2. Added flat_scalar_count_for_type() method to sema that recursively
     computes scalar count per CType (mirrors lowering's flat_scalar_count).
  3. When the array element type is a struct/union, the function now groups
     flat scalar initializer items per-struct, advancing the element index
     only when a full struct's worth of scalars is consumed.

Files changed:
  - src/frontend/sema/sema.rs (count_initializer_elements + flat_scalar_count_for_type)

Test: 325/327 pass (99.4%), unsized-struct-array-flat-init now passes.

Status: COMPLETED
