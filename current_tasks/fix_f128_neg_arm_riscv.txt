Fix F128 negation on ARM and RISC-V backends (in_progress)

Problem:
  F128 (long double) negation on ARM and RISC-V loses precision.
  The default emit_unaryop calls emit_float_neg, which on both ARM and RISC-V
  treats F128 as F64 -- using fneg.d (RISC-V) or fneg d0 (ARM) which only
  operates on 64-bit doubles, losing the full 128-bit IEEE quad-precision value.

  x86 correctly handles this with an emit_unaryop override that uses x87 fchs.

Fix:
  1. Add F128-specific dispatch in the shared trait emit_unaryop default to call
     a new emit_f128_neg method before falling through to emit_float_neg.
  2. Implement emit_f128_neg on ARM: load full f128 to Q0, flip sign bit via
     EOR on the high 64 bits, convert back to f64 approximation.
  3. Implement emit_f128_neg on RISC-V: load full f128 to a0:a1, XOR sign bit
     of a1, convert back to f64 approximation.
  4. Add regression test.
