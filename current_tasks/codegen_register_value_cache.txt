Task: Add codegen-level register value cache to skip redundant stack loads

Profiling shows the compiler spends ~35% of time in the peephole optimizer, which
mainly cleans up redundant store/load patterns generated by the stack-based codegen.

Root cause: Every IR value gets a stack slot, and every operand load re-reads from
the stack even when the value was just computed in %rax. For example:
  addq %rcx, %rax        # result in rax
  movq %rax, -24(%rbp)   # store result
  movq -24(%rbp), %rax   # immediately reload (redundant!)

Fix: Track in CodegenState which IR value(s) are currently in which registers.
Before emitting a load, check if the value is already in the target register.
This eliminates redundant loads at the source rather than cleaning up afterward.

Expected impact: ~30% fewer assembly lines generated, proportionally less work
for both the peephole optimizer and the external assembler.

Scope: x86 codegen only (CodegenState, operand_to_rax, value_to_reg, store_rax_to).

Status: in progress
