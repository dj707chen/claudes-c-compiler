Status: in_progress
Started: 2026-01-28

Problem: x86 kernel build fails at link time with undefined references to __bad_udelay.
The kernel's udelay() macro uses __builtin_constant_p(n) to select between constant and
variable delay paths. When the argument is a variable, __builtin_constant_p should return 0
and the constant path (which references __bad_udelay for error checking) should be dead-code
eliminated.

Root cause: IsConstant (the IR instruction for __builtin_constant_p) was left unresolved
when its operand was not a constant. The backend would emit 0 at codegen time, but by then
cfg_simplify had already run and couldn't eliminate the dead branches. The unreachable
__bad_udelay() calls survived into the object file, causing linker errors.

Fix: Added resolve_remaining_is_constant() to constant_fold.rs that resolves all remaining
IsConstant instructions to Copy(0) after the post-inline optimization passes but before
the main optimization loop. This allows cfg_simplify to fold the constant-false branches
and eliminate dead code paths.

The timing is critical: post-inline constant_fold resolves IsConstant to 1 when the operand
became constant through inlining. Only after that, remaining IsConstant are resolved to 0.
