Fix RISC-V inline asm "A" (Address) constraint for non-alloca operands

Problem:
RISC-V inline asm tests using "+A"(*ptr) with pointer parameters fail because
load_input_to_reg and preload_readwrite_output unconditionally compute the stack
slot address (addi reg, s0, offset) for Address operands instead of loading the
pointer value from the slot (ld reg, offset(s0)) when the operand is a non-alloca.

This causes AMO/LR/SC instructions to operate on the stack slot itself rather
than the memory the pointer points to. The "old" value read back is the raw
pointer address (e.g. 46912504503176) instead of the actual value at *ptr.

Fix:
- In load_input_to_reg: check is_alloca before using emit_addi_s0 for Address operands
- In preload_readwrite_output: same is_alloca check for Address case

Status: LOCKED
