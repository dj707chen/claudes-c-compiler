Fix __builtin_bswap16 constant folding produces zero

Bug: When __builtin_bswap16 is called with a constant argument (e.g.,
__builtin_bswap16(0x0102)), the constant folding pass in passes/constant_fold.rs
produces 0 instead of the correct byte-swapped value.

Root cause: fold_unaryop() uses is_32bit (which is true for I16/U16) and
computes (src as u32).swap_bytes(). For a 16-bit bswap of 0x0102:
  (0x0102u32).swap_bytes() = 0x02010000
Then IrConst::from_i64(0x02010000, IrType::I16) truncates to the lower
16 bits = 0x0000.

Fix: Add explicit I16/U16 case for bswap that uses (src as u16).swap_bytes().

Status: in_progress
