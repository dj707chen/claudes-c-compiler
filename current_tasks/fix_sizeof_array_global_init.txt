Fix sizeof(array) in global initializer const evaluation

Bug: sizeof(array_variable) returns pointer size (8) instead of the actual
array size when used in global initializer constant expressions.

Example:
    int arr[] = {1, 2, 3, 4, 5};
    int arr_size = sizeof(arr) / sizeof(arr[0]);
    // arr_size is 2 (wrong) instead of 5 (correct)
    // Because sizeof(arr) evaluates to 8 (pointer) instead of 20 (5*4)

This affects the common C idiom for computing array lengths in global scope.
The local/runtime version works correctly.

Root cause: sema const_eval's sizeof evaluation treats array variables as
pointer types when looking up their type in global scope.
