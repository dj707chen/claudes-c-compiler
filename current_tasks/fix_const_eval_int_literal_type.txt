Fix sema constant evaluator: IntLiteral/UIntLiteral produce wrong IrConst type

The sema const evaluator stores IntLiteral values as IrConst::I64 instead of
IrConst::I32. This causes ctype_from_ir_const() to infer CType::Long (64-bit)
instead of CType::Int (32-bit) for integer literal subexpressions, leading to
wrong constant folding when 32-bit width matters.

Example bug: (1 << 31) / 12582917 folds to 170 instead of -170 because:
1. IntLiteral(1) -> IrConst::I64(1) -> CType::Long (8 bytes)
2. Shl with is_32bit=false produces 2147483648 (positive in 64-bit)
3. Division gives 170 instead of -170

Fix: Make sema and lowering const evaluators produce IrConst::I32 for IntLiteral
and UIntLiteral, and return properly-typed IrConst from eval_const_binop_int.
