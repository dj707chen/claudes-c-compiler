Task: Fix char array string literal NUL truncation
Status: in_progress

Problem:
When a char array is initialized with a string literal whose length (including NUL)
exceeds the array size (e.g., `char sdrive[4] = "\0\0\0\0"` where the literal is 5 bytes),
the compiler was writing the trailing NUL terminator beyond the array bounds.

Per C11 6.7.9 p14, the trailing NUL should be silently dropped when the array is
exactly one byte too small to hold it.

On i686 (4-byte alignment), this overflow corrupted adjacent stack slots, causing
netcdf's unparsepath() to receive a clobbered parameter value.

Fix:
Added max_bytes parameter to emit_string_to_alloca to enforce array bounds.
Also fixed global init path in common.rs to use .ascii instead of .asciz when NUL doesn't fit.
