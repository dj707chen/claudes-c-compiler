Fix i686 in-body push/pop stack frame collision

Problem: On i686, emit_memcpy and emit_atomic_*_wide use push/pop instructions
inside the function body to save/restore ESI, EDI, EBX. These pushes extend
ESP below the allocated stack frame, which can overwrite values stored at the
bottom of the frame (e.g., spills at ebp - frame_size).

Root cause: The stack frame size calculation does not account for the extra
stack space consumed by in-body push/pop pairs in emit_memcpy (8 bytes for
push esi/edi) and atomic ops (up to 16 bytes for push ebx/esi/edx/eax).

Fix: Scan the IR for Memcpy and wide atomic instructions, and add appropriate
padding to the stack frame to prevent collisions.

Affected: i686 backend only (x86-64, ARM, RISC-V use different register save
strategies or have a red zone).

Impact: Fixes segfaults in jq, mquickjs, libsodium, and many other i686
project builds that use struct returns (sret) or atomics.
