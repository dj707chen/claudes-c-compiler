Task: Fix always_inline functions not inlined when caller exceeds absolute instruction cap

Status: in_progress

Problem:
The x86 kernel build fails with section mismatch errors because always_inline functions
(intel_pmu_init_hybrid, intel_pmu_init_glc, intel_pmu_init_grt) are NOT inlined into
intel_pmu_init (which is an __init function). These always_inline functions reference
__initconst data, so if they end up as standalone .text functions, modpost reports
section mismatches.

Root cause: The inlining pass has a MAX_CALLER_INSTRUCTIONS_ABSOLUTE_CAP (1000) that
prevents ALL inlining when the caller grows too large. intel_pmu_init grows to 2770+
instructions from inlining many small helpers, and then the absolute cap blocks the
always_inline functions (which have 200-250 instructions each and are not tiny/small
enough for the first pass).

Fix: Allow always_inline callees to bypass the absolute cap. The always_inline attribute
is a semantic requirement - the kernel depends on it for section correctness. Stack frame
concerns should not override C language semantics.
