Fix F128 (long double) static/global data emission on ARM and RISC-V

Problem:
- When emitting static/global long double values on ARM/RISC-V, the compiler writes
  the f64 approximation into the low 8 bytes and zeros in the high 8 bytes
- This produces an invalid IEEE binary128 value (essentially 0 or near-zero)
- The correct behavior is to convert the x87 80-bit bytes to IEEE binary128 format
- The conversion function already exists: x87_bytes_to_f128_bytes() in long_double.rs

Fix locations:
1. backend/common.rs emit_const_data(): ARM/RISC-V branch for IrConst::LongDouble
2. ir/ir.rs push_le_bytes(): byte-serialized init path for IrConst::LongDouble

Both should use x87_bytes_to_f128_bytes() instead of f64_val.to_bits()

Tests affected: compiler_suite_0080_0048 (va_arg with static LD struct),
compiler_suite_0010_0039 (LD multiply/compare), and other LD tests on ARM/RISC-V

Status: in_progress
