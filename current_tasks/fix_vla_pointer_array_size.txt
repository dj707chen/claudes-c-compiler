Fix VLA size computation for pointer-element arrays
====================================================
Date: 2026-01-26

Bug: For VLAs like `int *ap[n]`, the compiler computes the allocation size as
`n * sizeof(int)` instead of `n * sizeof(int*)`. This causes the VLA to be
undersized by half on 64-bit targets, leading to stack buffer overflows that
corrupt callee-saved register save areas.

Root cause: compute_vla_runtime_size() in stmt.rs uses sizeof_type(type_spec)
for the base element size, ignoring DerivedDeclarator::Pointer entries. For
`int *ap[n]`, type_spec is `int` and derived is [Pointer, Array(n)], so the
element size is 4 instead of 8.

Also affects: sizeof(vla_var) returns wrong value, and VLA stride computation.

Fix: Before computing base_elem_size, check whether the derived list contains
pointer derivations before the array dimensions. If so, use pointer size (8)
instead of sizeof(type_spec). Apply the same fix to compute_vla_local_strides.

Tests affected: compiler_suite_0103_* (alignment tests with VLA + alloca + register vars)
