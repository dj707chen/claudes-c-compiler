Fix long double global initialization to use correct architecture-specific encoding.

Problem:
- Global `long double` and `long double _Complex` values are emitted using f64 bit patterns
  instead of the correct architecture-specific format (x87 80-bit on x86, IEEE 754 binary128
  on ARM64/RISC-V)
- This causes all global long double values to be read as zero at runtime

Fix:
- Update emit_const_data() in backend/common.rs to use f64_to_x87_bytes() for x86-64
  and f64_to_f128_bytes() for ARM64/RISC-V when emitting IrConst::LongDouble
- Update push_le_bytes() in ir/ir.rs with an architecture-aware variant
- This fixes global long double complex values and standalone global long doubles

Tests affected: compiler_suite_0030_0027, compiler_suite_0030_0055, compiler_suite_0065_*,
  and other long double complex tests on x86 and ARM.
