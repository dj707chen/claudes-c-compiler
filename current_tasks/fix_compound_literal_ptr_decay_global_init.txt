Fix compound literal array-to-pointer decay in global/static pointer variable init

Bug: When a compound literal (bare or cast-wrapped) is used to initialize a
top-level pointer variable (not in a struct field), the compiler stores the
compound literal's data value directly into the pointer instead of creating
an anonymous global and storing its address.

Examples:
  static int *p = (int[]){ 42 };             // segfaults, p gets value 42 as addr
  static char *q = (char *)(unsigned char[]){ 0xFD };  // q gets NULL

Root cause: In global_init.rs, the compound literal handling for aggregate types
always inlines the data. It doesn't check whether the target is a pointer.
The struct-field path (global_init_compound.rs) has correct handling for bare
compound literals but is missing cast-unwrapping.

Fix:
1. In global_init.rs: detect when target is a pointer and compound literal is
   aggregate, create anonymous global instead of inlining
2. In global_init_compound.rs: unwrap Cast() to find compound literals in
   resolve_ptr_field_init()

This fixes libgrapheme project on all architectures.

Status: in_progress
