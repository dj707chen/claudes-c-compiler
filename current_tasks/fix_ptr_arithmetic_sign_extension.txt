Fix pointer arithmetic sign extension bug

When computing ptr + (int)uint32_val, the compiler fails to sign-extend the
int cast result from 32 bits to 64 bits before using it as a pointer offset.
This causes negative offsets like (int)-12u to be treated as large positive
offsets (4294967284), resulting in wild pointer arithmetic.

Root cause: try_lower_pointer_arithmetic() in expr.rs uses bare lower_expr()
for the integer operand without ensuring sign extension to I64. The cast from
U32->I32 is classified as Noop by classify_cast(), so the upper 32 bits remain
zero-extended instead of sign-extended.

Fix: In try_lower_pointer_arithmetic, after lowering the integer operand,
sign-extend it to I64 based on the C-level type signedness. This ensures
negative offsets work correctly.

Impact: Fixes mquickjs segfault in regex engine (lre_exec) and any other
code using negative pointer offsets via uint32-to-int casts.
