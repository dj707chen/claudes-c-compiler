Unify global init struct traversal with trait-based emitter pattern

STATUS: PARTIALLY DONE. See below for what was completed and what remains.

COMPLETED:
- Removed `write_struct_init_to_bytes` (~105 lines), replaced by `fill_struct_global_bytes`
  which already handles all the same cases (nested designators, complex fields, string
  literals in char arrays, bitfields, nested structs/unions, array fields, union semantics).
- Added `StructLayout::has_pointer_fields()` to common/types.rs, replacing 4 inline
  occurrences of `layout.fields.iter().any(|f| matches!(...) || type_has_pointer_elements(...))`
- Extracted `write_expr_to_bytes_or_ptrs()` helper, consolidating 5 instances of the
  "if ptr { resolve_ptr } else if bitfield { write_bitfield } else { write_const }" pattern
- Extracted `fill_composite_or_array_with_ptrs()` helper, consolidating 4 instances of the
  "if has_ptr { fill_nested_struct_with_ptrs } else { fill_struct_global_bytes }" branching

REMAINING (diminishing returns):
The full trait-based unification (InitEmitter with ByteEmitter/CompoundEmitter/HybridEmitter
and a single walk_struct_init) was not done because the three main traversal loops
(fill_struct_global_bytes, lower_struct_global_init_compound, fill_nested_struct_with_ptrs)
differ significantly in their handling of:
- Array fields (byte path has elaborate multi-dim/FAM/designator support)
- Bitfield packing (compound path packs into storage units with padding tracking)
- Union semantics (compound path has field_inits grouping phase)
- Flat init consumption (byte path consumes multiple items per array field)

A trait unification would need to abstract over these differences, which may add
complexity rather than reducing it. The current extraction of shared helpers eliminates
the most impactful duplication points.
