LOW PRIORITY: Remaining backend codegen deduplication opportunities

Completed items:
- CastKind enum + classify_cast() extracts shared cast classification
- classify_float_binop() + FloatOp enum shares float operation dispatch
- ARM operand_to_x0 movz/movk inlining deduplicated via emit_load_imm64
- ARM emit_sub_sp/emit_add_sp simplified to use emit_load_imm64
- classify_float_binop() unwrap_or(FloatOp::Add) latent bug now panics on all 3 backends
- ARM emit_va_start/emit_va_copy/emit_va_arg large-offset bug fixed
- SignedToUnsignedSameSize cast now properly masks sub-word types on ARM and RISC-V
- Default trait implementations for simple methods: emit_branch, emit_cond_branch,
  emit_unreachable, emit_indirect_branch, emit_label_addr, emit_va_end, emit_copy_i128.
  Each backend provides small primitives (jump_mnemonic, trap_instruction,
  emit_branch_nonzero, emit_jump_indirect) and the defaults compose them.
- emit_cast: Default implementation handles i128 widening/narrowing/copy via
  emit_sign_extend_acc_high/emit_zero_acc_high primitives. All three backends
  now use the shared default (no overrides needed).
- emit_binop decomposed: default dispatches float→emit_float_binop, int→emit_int_binop.
  x86-64 overrides emit_binop for 128-bit integer arithmetic.
- emit_float_binop: Shared default loads lhs/rhs, calls emit_float_binop_impl(mnemonic, ty).
  Each backend provides emit_float_binop_mnemonic() and emit_float_binop_impl().
- emit_i128_binop: Shared default dispatches to per-op primitives (emit_i128_add, emit_i128_sub,
  emit_i128_mul, emit_i128_and/or/xor, emit_i128_shl/lshr/ashr, emit_i128_divrem_call).
  Division/remainder func name selection is shared.
- emit_i128_cmp: Shared default dispatches Eq/Ne to emit_i128_cmp_eq(is_ne) and ordered
  comparisons to emit_i128_cmp_ordered(op). Algorithm structure (XOR+OR for equality,
  high-then-low for ordered) is shared.
- emit_inline_asm: Shared InlineAsmEmitter trait + emit_inline_asm_common() function
  extracts the 4-phase operand handling framework (classify constraints, assign registers,
  resolve tied/+ operands, build GCC numbering, load inputs, emit template, store outputs).
  Each backend implements InlineAsmEmitter with arch-specific constraint classification,
  register pools, load/store, and template substitution.

- emit_store/emit_load: Default trait implementations handle i128 pair + typed store/load
  with alloca/indirect dispatch. Each backend provides small primitives (emit_load_acc_pair,
  emit_store_pair_to_slot, emit_typed_store_to_slot, emit_load_ptr_from_slot, etc.).
- emit_gep: Default uses emit_slot_addr_to_secondary + emit_add_secondary_to_acc.
- emit_dyn_alloca: Default uses emit_round_up_acc_to_16, emit_sub_sp_by_acc, etc.
- emit_unaryop: Default dispatches i128/float/int then calls per-operation primitives
  (emit_float_neg, emit_int_clz, emit_int_bswap, etc.).
- emit_memcpy: Default loads addresses via emit_memcpy_load_dest/src_addr, then calls
  emit_memcpy_impl for the arch-specific copy loop.
- SlotAddr enum + resolve_slot_addr(): Shared 3-way alloca address resolution
  (OverAligned/Direct/Indirect) extracted from emit_store, emit_load, emit_gep,
  emit_memcpy defaults. Eliminates duplicated if/else chains.
- AsmOperand::copy_metadata_from(): Shared operand metadata copying for tied
  operands and "+" read-write propagation. Consolidates 3 inline copy blocks.
- Inline asm tied-operand resolution: Merged two separate loops (Tied kind +
  input_tied_to vector) into a single pass.

- emit_return: Default implementation dispatches i128/f128/f32/f64/int returns using
  arch-specific primitives (emit_return_i128_to_regs, emit_return_f128_to_reg, etc.).
  All three backends now use the shared default.
- CallArgClass enum + classify_call_args(): Shared function call argument classification
  with CallAbiConfig for arch-specific register counts and alignment rules.
- emit_call: All three backends now use classify_call_args() with struct support
  (StructByValReg, StructByValStack, LargeStructStack variants). Shared
  compute_stack_arg_space() (ARM/RISC-V) and compute_stack_push_bytes() (x86).
  Previously ~1343 lines of duplicated classification logic; now shared.

Remaining opportunities (diminishing returns):

1. Parameter classification: emit_store_params still independently classify params. The
   shared classify_call_args() could be extended to cover this, but the store operations
   are sufficiently arch-specific that the benefit is limited.

2. emit_call emission phases: The register loading, stack arg handling, and return value
   storage within emit_call are still per-backend (arch-specific instructions). Further
   extraction would require many new ArchCodegen primitives for diminishing returns.
