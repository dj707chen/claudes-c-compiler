Fix complex long double promotion at function call sites
Priority: MEDIUM

Problem:
When passing a _Complex double argument to a function expecting _Complex long double,
the implicit conversion fails, producing zeros.

Root cause:
The complex_to_complex conversion in complex.rs correctly loads the F64 real/imag parts,
"casts" them to F128, and stores them at offsets 0 and 16 in a 32-byte alloca.
However, classify_cast in codegen_shared.rs treats F64 -> F128 as a Noop since
"F128 (long double) is computed as F64". This means only 8 bytes are written to each
16-byte slot in the ComplexLongDouble alloca. The callee expects 16 bytes at each slot
(x87 extended format) but only gets 8 bytes (F64 format), so it reads garbage.

The architectural decision to treat F128 as F64 in the IR works for simple scalar
operations but breaks complex number memory layout when different precisions interact.

Fix options:
1. Make the F64->F128 store emit proper x87 fstpt instructions for ComplexLongDouble
   allocas. This requires the backend to recognize F128 stores and use x87 fldl+fstpt.
2. Change complex_to_complex to use Memcpy from the source directly when both types
   are the same (noop), and for mixed precisions, emit explicit x87 load/store pairs.
3. Long-term: properly represent F128 (x87 80-bit) in the IR as a distinct type that
   uses 16-byte storage, rather than aliasing it to F64.

Test cases affected:
- compiler_suite_0025_0078, 0025_0089 (complex float/double passed to CLD functions)
- compiler_suite_0026_0254 (2D complex array init also related)
- compiler_suite_0065_0053, 0065_0109, 0065_0276 (complex long double precision issues)

Note: This only affects x86-64. ARM and RISC-V use IEEE 128-bit or double for long double.
